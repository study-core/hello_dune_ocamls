(* 
######################################################################################################################################################

ç¬¬ä¸€ç±» æ¨¡å—ï¼š

              ã€å¯ä»¥ä½œä¸ºå‚æ•°ä¼ é€’ï¼Œå¯ä»¥ä½œä¸ºè¿”å›å€¼è¿”å›ã€‘

######################################################################################################################################################


OCaml è§†ä¸ºåˆ†ä¸ºä¸¤éƒ¨åˆ†ï¼š

      1. æ¶‰åŠã€å€¼ã€‘å’Œã€ç±»å‹ã€‘çš„         æ ¸å¿ƒè¯­è¨€
      
      2. æ¶‰åŠã€æ¨¡å—ã€‘å’Œã€æ¨¡å—ç­¾åã€‘çš„   æ¨¡å—è¯­è¨€



è¿™äº›å­è¯­è¨€æ˜¯åˆ†å±‚çš„ï¼š

  å› ä¸º æ¨¡å— å¯ä»¥åŒ…å« ç±»å‹ å’Œ å€¼

  ä½† æ™®é€šå€¼ ä¸èƒ½åŒ…å« æ¨¡å— æˆ– æ¨¡å—ç±»å‹

è¿™æ„å‘³ç€ä¸èƒ½æ‰§è¡Œè¯¸å¦‚ï¼š 

      å®šä¹‰ å€¼ ä¸º æ¨¡å—çš„å˜é‡ 
      
      å°† æ¨¡å— ä½œä¸º å‚æ•°çš„å‡½æ•° ä¹‹ç±»çš„æ“ä½œ





ã€è§£å†³ã€‘ï¼š   ç¬¬ä¸€ç±»æ¨¡å—
*)


(* 
   
ç¬¬ä¸€ç±»æ¨¡å—    æ˜¯é€šè¿‡æ‰“åŒ…å…·æœ‰å…¶æ»¡è¶³çš„ ç­¾å çš„æ¨¡å—  æ¥åˆ›å»ºçš„


è¿™æ˜¯ä½¿ç”¨ module å…³é”®å­—å®Œæˆçš„

ä¸‹é¢æ˜¯  å£°æ˜ module ç±»å‹ å’Œ å®šä¹‰ module çš„è¯­æ³•

*)

module type X_int = sig val x : int end;;

(* 
  å®šä¹‰ä¸€èˆ¬æ¨¡å—

  module M = struct .. end                  (* module definition *)

  module M: sig .. end= struct .. end       (* module and signature *)



  è€Œ å‡½å­ è¯­æ³•ä¸ºï¼š  module å‡½å­Name (å…¥å‚çš„æ¨¡å—å˜é‡å : å…¥å‚çš„æ¨¡å—ç±»å‹) = struct .. end   å¦‚ï¼š module MakeSet (Element : ELEMENT) = struct .. end 
*)
module Three : X_int = struct let x = 3 end;;   (* ä¸€èˆ¬æ¨¡å— module and signature *) 

Three.x;;

(* 
------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------
*************************************************   
å°† ä¸€èˆ¬æ¨¡å— è½¬æˆ ç¬¬ä¸€ç±»æ¨¡å—
*************************************************


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


è½¬æ¢è¯­æ³•ï¼š


let  ç¬¬ä¸€ç±»æ¨¡å—å = (module è¦è¢«è½¬çš„ä¸€èˆ¬æ¨¡å— :  ä¸€èˆ¬æ¨¡å—çš„ç±»å‹)


let first-class-moduleName = (module moduleName : moduleType)

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------
*)
let three = (module Three : X_int);;    (* val three : (module X_int) = <module> *)



(* 
*************************************************   
æ¨æ–­ å’Œ åŒ¿åæ¨¡å—
*************************************************
*)
module Four = struct let x = 4 end;;   (* é€šè¿‡ç±»å‹æ¨æ–­ï¼Œå…¶ç±»å‹ä¸º module X_int *)  (* module Four : sig val x : int end *)

(* val numbers : (module X_int) list = [<module>; <module>] *)
let numbers = [ three; (module Four) ];;   (* ç±»å‹æ¨æ–­ Four ä¸º  ç¬¬ä¸€ç±»æ¨¡å— *)
(* è¿˜å¯ä»¥å†™æˆ åŒ¿åæ¨¡å— *)
let numbers = [three; (module struct let x = 4 end)];;



(* 
*************************************************   
æ‹†å¼€  ç¬¬ä¸€ç±» æ¨¡å—
*************************************************



ä¸ºäº†è®¿é—®ä¸€æµæ¨¡å—çš„å†…å®¹ï¼Œæ‚¨éœ€è¦å°†å…¶è§£åŒ…åˆ°æ™®é€šæ¨¡å—ä¸­ã€‚è¿™å¯ä»¥ä½¿ç”¨ val å…³é”®å­—æ¥å®Œæˆï¼š


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


æ‹†å¼€è¯­æ³•ï¼š

  


  module æ‹†è§£å‡ºæ¥çš„ä¸€èˆ¬æ¨¡å— = (val ç¬¬ä¸€ç±»æ¨¡å—å  : ä¸€èˆ¬æ¨¡å—çš„ç±»å‹)

  module moduleName = (val first-class-moduleName : moduleType)
    


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

*)

(* module New_three : X_int *)
module New_three = (val three : X_int);;    (* ã€æ³¨æ„ï¼Œ çœ‹è¿™ä¸ªå•Šå•Šå•Šå•Šå•Šå•Šå•Šå•Šå•Šå•Šå•Šå•Šå•Šå•Šå•Šå•Šå•Šå•Šå•Š  !!!!!!!!!!!!!!!!!!!!!!1ã€‘ *)

(* æˆ–è€… module New_three = (val three);; *)


New_three.x;;


(* 

*****************************************************************************************************
*****************************************************************************************************
*****************************************************************************************************

ã€ç»“è®ºã€‘ï¼š

    æƒ³è¦åœ¨ å‡½æ•°ä¸­ä½¿ç”¨  module å‚æ•°ï¼š

        
    
        åˆ™éœ€è¦å…ˆå°† module è½¬æ¢æˆ  ç¬¬ä¸€ç±»æ¨¡å—ï¼›

        å¹¶åœ¨è¦æ˜¯ç”¨çš„åœ°æ–¹ è§£å¼€ ç¬¬ä¸€ç±»æ¨¡å—ä¸º æ™®é€šæ¨¡å—

*****************************************************************************************************
*****************************************************************************************************
*****************************************************************************************************

*)



(* 
------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------
*************************************************   
ç”¨äº æ“ä½œ ç¬¬ä¸€ç±» æ¨¡å—çš„ å‡½æ•°    
*************************************************
------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------
*)

(* val to_int : (module X_int) -> int = <fun> *)
let to_int m =
  let module M = (val m : X_int) in
  M.x;;


(* val plus : (module X_int) -> (module X_int) -> (module X_int) = <fun> *)
let plus m1 m2 =(module struct let x = to_int m1 + to_int m2 end : X_int);; (* å‡½æ•° plus è¿”å›ä¸€ä¸ªæ–°çš„ first-class moduleï¼Œå…¶çš„ x å€¼ä¸º first-class m1 çš„ x åŠ ä¸Š first-class m2 çš„ x *)


(* ä½¿ç”¨æ¨¡å¼åŒ¹é… *)
let to_int (module M : X_int) = M.x;;  (* æ¯”ä¸Šé¢çš„  to_int å®šä¹‰ ç®€æ´ï¼Œ æ˜ç¡®äº†éœ€è¦ä¼ å…¥ first-class M ç±»å‹ *)  




let six = plus three three;;
to_int (List.fold_left  plus six [three;three]);;


(* 
*************************************************   
æ›´ä¸°å¯Œçš„ä¾‹å­
*************************************************
*)

(* module  type *)
module type Bumpable = sig
  type t
  val bump : t -> t
end;;

(* 
  é€šè¿‡ç±»å‹æ¨æ–­ï¼Œå…¶ç±»å‹ä¸º 
          sig
            type t
          
            val bump : t -> t
          end 
  ç›®å‰ä¹Ÿå°±æ˜¯ module type Bumpable çš„ ç±»å‹
*)
module Int_bumper = struct
  type t = int
  let bump n = n + 1
end;;
(* 
  é€šè¿‡ç±»å‹æ¨æ–­ï¼Œå…¶ç±»å‹ä¸º 
          sig
            type t
          
            val bump : t -> t
          end 
  ç›®å‰ä¹Ÿå°±æ˜¯ module type Bumpable çš„ ç±»å‹
*)
module Float_bumper = struct
  type t = float
  let bump n = n +. 1.
end;;

let int_bumper = (module Int_bumper : Bumpable);;   (* è½¬æ¢æˆ ç¬¬ä¸€ç±» æ¨¡å— *)

(* æ³¨æ„ï¼š  ç¬¬ä¸€ç±»æ¨¡å— ä¸å¯ä»¥ç›´æ¥è¢«ä½¿ç”¨ï¼Œ å› ä¸ºå®ƒæ˜¯ æŠ½è±¡çš„ï¼Œ type t æ˜¯æŠ½è±¡çš„ï¼Œæ‰€ä»¥æ— æ³•è¢«æ¨æ–­ï¼Œéœ€è¦çœ‹ä¸‹é¢çš„ ä¾‹å­åšæ³• *)
let (module Bumper) = int_bumper in Bumper.bump 3;;
(* 
Error:  This expression has type Bumper.t but an expression was expected of type 'a
        The type constructor Bumper.t would escape its scope   
*)


(* ä¸ºäº†ä½¿ int_bumper å¯ç”¨ï¼Œæˆ‘ä»¬éœ€è¦å…¬å¼€ç±»å‹ Bumpable.t å®é™…ä¸Šç­‰äº int ã€‚ä¸‹é¢æˆ‘ä»¬å°†ä¸º int_bumper æ‰§è¡Œæ­¤æ“ä½œï¼Œå¹¶ä¸º float_bumper æä¾›ç›¸åº”çš„å®šä¹‰ã€‚ *)

(* æ·»åŠ    ã€å…±äº«é™åˆ¶ã€‘  with type xxx *)

let int_bumper = (module Int_bumper : Bumpable with type t = int);;         (* å°† type t æ˜ç¡®ä¸º intï¼Œ è¿™æ—¶å€™ first-class module int_bumper å°±ä¸æ˜¯æŠ½è±¡çš„äº† *)

let float_bumper = (module Float_bumper : Bumpable with type t = float);;   (* å°† type t æ˜ç¡®ä¸º float è¿™æ—¶å€™ first-class module float_bumper å°±ä¸æ˜¯æŠ½è±¡çš„äº† *)

(* å°†ç¬¬ä¸€ç±»æ¨¡å—è½¬æ¢å›æ™®é€šæ¨¡å—ï¼Œå¹¶ç»‘å®šåˆ°ä¸€ä¸ªä¸´æ—¶çš„ Module Bumper ä¸Šï¼Œå¹¶ä½¿ç”¨ç‚¹è¯­æ³•è®¿é—®å…¶å†…å®¹ *)  
(* 
  æ¨¡å¼åŒ¹é…è§£åŒ…: 
      ç¼–è¯‘å™¨ä»ä¼šæ¨æ–­ int_bumper çš„å…·ä½“ç±»å‹   (ç›®å‰ä½¿ç”¨æœ€å¤šçš„è¯­æ³•ï¼Œæ—¥å¸¸é¦–é€‰)
*)
(* let (module Bumper) = ... è¿™ç§ç¼©å†™è¯­æ³•åœ¨æ¨æ–­ç±»å‹æ—¶éå¸¸ä¾èµ–ä¸Šä¸‹æ–‡ *)
let (module Bumper) = int_bumper in Bumper.bump 3;;  
(* 
  æ˜¾å¼è§£åŒ…: éšå¼ç±»å‹æ¨æ–­
      ç¼–è¯‘å™¨ä¼šæ¨æ–­ int_bumper çš„å…·ä½“ç±»å‹   (ä¸æ¨èä½¿ç”¨)
*)
let module Bumper = (val int_bumper) in Bumper.bump 3;;   
(* 
 æ˜¾å¼ç±»å‹è§£åŒ…: å¸¦ç±»å‹æ³¨è§£çš„è§£åŒ…è¯­æ³•
   æœ€å®‰å…¨ï¼Œæœ€æ˜ç¡®ï¼Œä½†æœ€å†—é•¿ï¼Œå¤§å‹é¡¹ç›®ä¸­ä½¿ç”¨
*)
let module Bumper = (val int_bumper : Bumpable with type t = int) in Bumper.bump 3;;


let (module Bumper) = float_bumper in Bumper.bump 3.5;;
































(* 
***************************************************************************************************************************************************
***************************************************************************************************************************************************
***************************************************************************************************************************************************   
è¿˜å¯ä»¥å¤šæ€åœ°ä½¿ç”¨è¿™äº›ä¸€æµçš„æ¨¡å—                           first-class module çš„å¤šæ€ 
***************************************************************************************************************************************************
***************************************************************************************************************************************************
***************************************************************************************************************************************************
ä»¥ä¸‹å‡½æ•°é‡‡ç”¨ä¸¤ä¸ªå‚æ•°ï¼š Bumpable æ¨¡å— å’Œä¸  æ¨¡å—çš„ t ç±»å‹ç›¸åŒç±»å‹çš„å…ƒç´ åˆ—è¡¨ï¼š  

(å³   ä¸‹åˆ—çš„ a ã€æœ¬åœ°æŠ½è±¡ç±»å‹ã€‘)
*)

(* 
  è¯¥å‡½æ•°çš„ç±»å‹ç­¾åä¸ºï¼š

      val bump_list : (module Bumpable with type t = 'a) -> 'a list -> 'a list = <fun> 


      å¦‚æœåªæ˜¯å®šä¹‰ä¸ºï¼š

      let bump_list  (module Bumper : Bumpable) (l: 'a list)  =  List.map Bumper.bump l;;

      åˆ™ä¼šå¯¼è‡´ç±»å‹é”™è¯¯ï¼Œå› ä¸º Bumper æ¨¡å—çš„ t ç±»å‹æ˜¯æŠ½è±¡çš„ï¼Œæ— æ³•æ¨æ–­

      
      
      è¿™æ—¶å€™åœ¨å‡½æ•° bump_list åŠ å…¥ ã€æœ¬åœ°æŠ½è±¡ç±»å‹ã€‘  a ï¼Œ å³å¯è§£å†³ç±»å‹é”™è¯¯ (ç±»ä¼¼å‡½æ•°çš„åŠ ä¸Š <æ³›å‹å‚æ•°> ä¸€æ ·)

      è¿™æ—¶å€™å°±é™å®šäº† Bumper æ¨¡å—çš„ t ç±»å‹ã€å›ºå®šä¸ºäº†ã€‘ä¸º a (åƒæ˜¯æŒ‡å®šäº†çœŸå®ç±»å‹ï¼Œå¦‚ int bool ä¸€æ ·ä¸è¿‡å®ƒå« a ç±»å‹)ï¼Œ ä»è€Œè§£å†³äº†ç±»å‹é”™è¯¯

      æ‰€ä»¥  (type a) çš„å†™æ³•å°±æ˜¯å…¶ä»–è¯­è¨€ä¸­çš„ æ³›å‹å‚æ•°   T çš„æ„æ€
*)
let bump_list  (type a)  (module Bumper : Bumpable with type t = a) (l: a list)  =  List.map Bumper.bump l;;

bump_list int_bumper [1;2;3];;

bump_list float_bumper [1.5;2.5;3.5];;

(* 
åœ¨æ­¤ç¤ºä¾‹ä¸­ï¼Œ a æ˜¯ ã€æœ¬åœ°æŠ½è±¡ç±»å‹ã€‘ã€‚

å¯¹äºä»»ä½•å‡½æ•°ï¼Œæ‚¨éƒ½å¯ä»¥å£°æ˜ (type a) å½¢å¼çš„ ä¼ªå‚æ•°ï¼Œå®ƒå¼•å…¥äº†åä¸º a çš„æ–°ç±»å‹ã€‚





è¯¥ç±»å‹çš„ä½œç”¨ï¼š                   ç±»ä¼¼äº å…¶ä»–è¯­è¨€ä¸­å‡½æ•°çš„ æ³›å‹å‚æ•° ã€‚




åœ¨ä¸Šé¢çš„ç¤ºä¾‹ä¸­ï¼Œæœ¬åœ°æŠ½è±¡ç±»å‹ç”¨ä½œå…±äº«çº¦æŸçš„ä¸€éƒ¨åˆ†ï¼Œã€è¯¥å…±äº«çº¦æŸå°†ç±»å‹ B.t ä¸ ä¼ å…¥çš„ åˆ—è¡¨   a list å…ƒç´ çš„ç±»å‹è”ç³»èµ·æ¥ã€‘ å³ï¼š B.t = a å’Œ a list

*)


(* 

ã€æœ¬åœ°æŠ½è±¡ç±»å‹ã€‘ çš„å…³é”®å±æ€§ä¹‹ä¸€æ˜¯ï¼Œå®ƒä»¬åœ¨å®šä¹‰çš„å‡½æ•°ä¸­ä½œä¸ºæŠ½è±¡ç±»å‹è¿›è¡Œå¤„ç†ï¼Œä½†ä»å¤–éƒ¨æ¥çœ‹æ˜¯å¤šæ€çš„  

å¦‚ï¼š
*)
type _ value = 
  | Int : int -> int value
  | String : string -> string value

(* å¿…é¡»ç”¨ (type a) æ‰èƒ½è®©ç¼–è¯‘å™¨çŸ¥é“è¿”å›å€¼çš„ç±»å‹ä¼šå˜åŒ– *)
(* å‡½æ•° get_val çš„ç±»å‹ç­¾åä¸ºï¼š val get_val : type a. a value -> a = <fun>  (å³ï¼š 'a value -> 'a) *)
(* å…¶ä¸­ 'a å’Œ (type a) å’Œ type a. çš„åŒºåˆ«è¯·çœ‹ a_type_a.ml æ–‡ä»¶ *)

let get_val (type a) (v : a value) : a =
  match v with
  | Int i -> i       (* ç¼–è¯‘å™¨æ¨æ–­ï¼šæ­¤æ—¶ a æ˜¯ int *)
  | String s -> s    (* ç¼–è¯‘å™¨æ¨æ–­ï¼šæ­¤æ—¶ a æ˜¯ string *)

let wrap_in_list (type a) (x : a) = [x];;  (* å¯è§ (type  a) çš„å†™æ³•å°±æ˜¯å…¶ä»–è¯­è¨€ä¸­çš„ æ³›å‹å‚æ•°   T çš„æ„æ€ *)

wrap_in_list 18;;

wrap_in_list true;;

wrap_in_list "Gavin";;


(* ä¸€èˆ¬æ¥è¯´ï¼Œ (type a) åªåœ¨ ç¬¬ä¸€ç±»æ¨¡å—(è§£åŒ…)  å’Œ GADTs ä¸­ä½¿ç”¨  *)

(* 

************************************************************************************************************
************************************************************************************************************
************************************************************************************************************

ä¸€äº›ä¸èƒ½ä½¿ç”¨ (type a) çš„æƒ…å†µï¼š

************************************************************************************************************
************************************************************************************************************
************************************************************************************************************

*)

(* 
  1ã€å¦‚æœå†™ä¸€ä¸ªå¯¹æŸç§ç±»å‹åšæ“ä½œçš„æ™®é€šå‡½æ•°ï¼Œç»å¯¹ä¸è¦ç”¨ (type a) , å¦‚ åŠ æ³•è¿ç®—

  å› ä¸º åŠ æ³•ç¼–è¯‘å™¨ä¼šé»˜è®¤æ¨æ–­å‡ºç±»å‹ä¸º int ï¼Œè€Œ (type a) ä¸Šä¸€ä¸ª a ç±»å‹ï¼Œæ— æ³•è¿›è¡Œ åŠ æ³•è¿ç®—
*)
(* Error: This expression has type a but an expression was expected of type int *)
let double_int (type a) (x : a) = x + x;;  

(* 
  ç›´æ¥ç”¨ 'a è®©ç¼–è¯‘å™¨(æ ¹æ® + å·)æ¨æ–­å‡º intï¼Œæˆ–è€…ç›´æ¥æŒ‡å®š int
  ä¸‹é¢çš„ double_int å‡½æ•°çš„ç±»å‹ä¸ºï¼š val double_int : int -> int = <fun>
*)
let double_int (x : 'a) = x + x;; 
(* 
  ç›´æ¥ç”¨ 'a è®©ç¼–è¯‘å™¨(æ ¹æ® +. å·)æ¨æ–­å‡º floatï¼Œæˆ–è€…ç›´æ¥æŒ‡å®š float
  ä¸‹é¢çš„ double_float å‡½æ•°çš„ç±»å‹ä¸ºï¼š val double_float : float -> float = <fun>
*)
let double_float (x : 'a) = x +. x;; 
(* 
  ç›´æ¥ç”¨ 'a è®©ç¼–è¯‘å™¨(æ ¹æ® ^ å·)æ¨æ–­å‡º stringï¼Œæˆ–è€…ç›´æ¥æŒ‡å®š string
  ä¸‹é¢çš„ double_string å‡½æ•°çš„ç±»å‹ä¸ºï¼š val double_string : string -> string = <fun>
*)
let double_string (x : 'a) = x ^ x;; 


(* 
  2ã€List çš„è§£æ„
*)
(* é”™è¯¯ï¼šList.hd æœŸå¾… 'a listï¼Œä½† a ä¸æ˜¯ list *)
let head (type a) (x : a) = List.hd x;;

(* 
  head å‡½æ•°çš„ç±»å‹ä¸ºï¼š val head : 'a list -> 'a = <fun>
*)
let head (x : 'a) = List.hd x;;












(* 
   

************************************************************************************************************
************************************************************************************************************
************************************************************************************************************
************************************************************************************************************
************************************************************************************************************
************************************************************************************************************

(* ä¸€èˆ¬æ¥è¯´ï¼Œ (type a) åªåœ¨ ç¬¬ä¸€ç±»æ¨¡å—(è§£åŒ…)  å’Œ GADTs ä¸­ä½¿ç”¨  *)


ã€æœ¬åœ°æŠ½è±¡ç±»å‹ã€‘ çš„ä¸€ä¸ªå¸¸è§ç”¨é€”æ˜¯    -----------------------             ã€åˆ›å»º å¯ç”¨äºæ„é€ æ¨¡å— çš„ æ–°ç±»å‹ã€‘

è¿™æ˜¯åˆ›å»ºæ–°çš„  ç¬¬ä¸€ç±»æ¨¡å—çš„ç¤ºä¾‹: 


************************************************************************************************************
************************************************************************************************************
************************************************************************************************************
************************************************************************************************************
************************************************************************************************************
************************************************************************************************************


å¾ˆæ£’çš„ä¾‹å­ ----
*)

module type Comparable = sig
  type t
  val compare : t -> t -> int
end;;

(* val create_comparable :  ('a -> 'a -> int) -> (module Comparable with type t = 'a) = <fun> *)
let create_comparable (type a) compare =   (* ä½¿ç”¨ ã€æœ¬åœ°æŠ½è±¡ç±»å‹ã€‘*)
  (module struct
    type t = a
    let compare = compare
  end : Comparable with type t = a);;  (* ä½¿ç”¨ ã€å…±äº«é™åˆ¶ã€‘    with type t = a  *)


create_comparable Int.compare;;     (* - : (module Comparable with type t = int) = <module> *)

create_comparable Float.compare;;   (* - : (module Comparable with type t = float) = <module> *)




(* 

ã€å…±äº«é™åˆ¶ã€‘çš„ä½¿ç”¨

å…±äº«é™åˆ¶è¯­æ³•ä¸ºï¼š <Module_type> with type <type> = <type'>

*)

(* 

  åœºæ™¯ä¸€ï¼šé€æ˜åŒ–ç±»å‹

*)
module type ID = sig
  type t
  val of_int : int -> t
  val to_int : t -> int
end

(* âŒ é”™è¯¯ç¤ºèŒƒï¼šå®Œå…¨å¯†å° *)
module UserID : ID = struct
  type t = int
  let of_int n = n
  let to_int n = n
end

let my_id = UserID.of_int 10 in UserID.to_int my_id + 5 ;;
(*  
   æŠ¥é”™ï¼šUserID.to_int è¿”å›çš„æ˜¯æŠ½è±¡ç±»å‹ tï¼Œç¼–è¯‘å™¨ä¸æ‰¿è®¤å®ƒæ˜¯ intï¼Œæ‰€ä»¥ä¸èƒ½åš + 5 æ“ä½œã€‚ *)

(* âœ… æ­£ç¡®ç¤ºèŒƒï¼šä½¿ç”¨å…±äº«é™åˆ¶å…¬å¼€åº•å±‚ç±»å‹ *)
module SafeID : ID with type t = int = struct
  type t = int
  let of_int n = n
  let to_int n = n
end

(* ç°åœ¨å¯ä»¥è¿è¡Œäº†ï¼Œå› ä¸ºç¼–è¯‘å™¨çŸ¥é“ SafeID.t å°±æ˜¯ int *)
let my_id = SafeID.of_int 10 in SafeID.to_int my_id + 5 ;;
let result = SafeID.to_int (SafeID.of_int 10) + 5 ;;


(* 

  åœºæ™¯äºŒï¼šè®©ä¸¤ä¸ªæ¨¡å—â€œè¯´åŒä¸€ç§è¯­è¨€â€

*)
module type Printer = sig
  type data
  val print : data -> unit
end

module type Reader = sig
  type data
  val read : unit -> data
end

(* æˆ‘ä»¬å¸Œæœ›åˆ›å»ºä¸€ä¸ªç³»ç»Ÿï¼ŒReader è¯»åˆ°çš„æ•°æ®ï¼ŒPrinter èƒ½ç›´æ¥æ‰“å° *)
(* å¿…é¡»é€šè¿‡å…±äº«é™åˆ¶å°†ä¸¤è€…çš„ data éƒ½æŒ‡å‘ string *)

let sync_data 
  (type a)
  (module R : Reader with type data = a)
  (module P : Printer with type data = a) =
  let d = R.read () in
  P.print d


(* 

  åœºæ™¯ä¸‰ï¼šåœ¨å‡½å­ï¼ˆFunctorï¼‰ä¸­çš„ç±»å‹ä¼ æ’­

*)
module type Comparable = sig
  type t
  val compare : t -> t -> int
end

(* æˆ‘ä»¬å®šä¹‰ä¸€ä¸ªæ’åºå‡½å­ *)
module MakeSort (Item : Comparable) = struct
  type elt = Item.t
  let sort l = List.sort Item.compare l
end

(* âš ï¸ é—®é¢˜ï¼šMakeSort(Int) ç”Ÿæˆçš„æ¨¡å—ï¼Œå®ƒçš„ elt ç±»å‹æ˜¯æŠ½è±¡çš„ *)
(* ğŸ’¡ æ”¹è¿›ï¼šåœ¨å‡½å­è¿”å›æ—¶ä½¿ç”¨å…±äº«é™åˆ¶ *)

module MakeSortSecure (Item : Comparable) : sig
  (* 
    è¿™ç§åœ¨ç­¾åå†…éƒ¨ (Functor çš„è¿”å›ç­¾å) ç›´æ¥ç»™æŠ½è±¡ç±»å‹ elt ä¸€ä¸ªâ€œç­‰å·å®šä¹‰â€çš„åšæ³•ï¼Œåœ¨æ•ˆæœä¸Šç­‰åŒäº å…±äº«é™åˆ¶
    å®ƒæ˜ç¡®å‘Šè¯‰ç¼–è¯‘å™¨ï¼šè¾“å‡ºæ¨¡å—çš„ elt æ°¸è¿œç­‰äºè¾“å…¥æ¨¡å—çš„ Item.t
  *)
  type elt = Item.t  (* è¿™é‡Œçš„ç­‰å·å…¶å®å°±æ˜¯ä¸€ç§å…±äº«é™åˆ¶ *)
  val sort : elt list -> elt list
end = struct
  type elt = Item.t
  let sort l = List.sort Item.compare l
end


(* 
  åˆå¦‚: 
*)
module type Sorter = sig
  type elt
  val sort : elt list -> elt list
end

module MakeSortSecure (Item : Comparable) : Sorter with type elt = Item.t = (* <--- è¿™é‡Œä½¿ç”¨äº† with type *)
struct
  type elt = Item.t
  let sort l = List.sort Item.compare l
end


(* 

  åœºæ™¯å››ï¼šç±»å‹ç²¾åŒ–ä¸é™æ€æ–­è¨€

*)
module type STORE = sig
  type key
  type value
  val get : key -> value
end

(* é€šè¿‡é™åˆ¶ key = stringï¼Œè¿™ä¸ªå®ç°å°±åªèƒ½å¤„ç†å­—ç¬¦ä¸²ç´¢å¼• *)
module StringStore : STORE with type key = string = struct
  type key = string
  type value = int
  let get k = String.length k
end

(* 

  åœºæ™¯äº”ï¼šåµŒå¥—æ¨¡å—çš„å…³è”çº¦æŸ (Nested Module Constraints)

*)
module type PROTOCOL = sig
  module Msg : sig type t end
  module Crypto : sig type plaintext end
end

(* å¼ºåˆ¶è¦æ±‚ Msg.t å’Œ Crypto.plaintext å…±äº«åŒä¸€ä¸ªåº•å±‚ç±»å‹ *)
module MyProto : PROTOCOL with type Msg.t = string 
                         and type Crypto.plaintext = string = struct
  module Msg = struct type t = string end
  module Crypto = struct type plaintext = string end
end


(* 

  åœºæ™¯å…­ï¼šé‡å†™  ã€ç ´åæ€§æ›¿æ¢ã€‘

  è¯­æ³• XxxModuleTpye with type t := int  å’Œ å…±äº«é™åˆ¶ ä¸å¤ªä¸€æ · ï¼ˆç”¨äº† := è€Œä¸æ˜¯ = ï¼‰ï¼Œ æŸ¥çœ‹ functor_test.ml æ–‡ä»¶ è®²è§£

*)

module type BOX = sig
  type t
  val reveal : t -> string
end



(* 

  ç”Ÿæˆçš„ INT_BOX ç­‰ä»·äºï¼š
    sig
      type t = int     <-- t è¿˜åœ¨
      val reveal : int -> string
    end 

    vscode æç¤ºæ˜¯:
    sig
      type t = int

      val reveal : t -> string
    end

*)
module type INT_BOX = BOX with type t = int

(* 

  ç”Ÿæˆçš„ PLAIN_BOX ç­‰ä»·äºï¼š
    sig
      val reveal : int -> string   <-- t å½»åº•æ¶ˆå¤±äº†ï¼Œç›´æ¥è¢«æ›¿æ¢è¿›äº†å‡½æ•°ç­¾å
    end

    vscode æç¤ºæ˜¯:
    sig
      val reveal : int -> string
    end
   
*)
module type PLAIN_BOX = BOX with type t := int

(* å®šä¹‰ä¸€ä¸ªç¬¦åˆ PLAIN_BOX çš„æ¨¡å— *)
module MyBox : PLAIN_BOX = struct
  (* æ³¨æ„ï¼šè¿™é‡Œä¸èƒ½å†™ type t = intï¼Œå› ä¸º PLAIN_BOX æ¥å£é‡Œå·²ç»æ²¡æœ‰ t äº† *)
  let reveal n = string_of_int n
end

let x : MyBox.t = 10;;
let x : MyBox.int = 10;;


(* 

ä¸ºä»€ä¹ˆè¦ç”¨ := è¿™ç§â€œç ´åæ€§â€çš„æ–¹å¼ï¼Ÿ
    åœ¨å¤§å‹é¡¹ç›®ï¼ˆå¦‚ Mina Protocol é¡¹ç›®ï¼‰ä¸­ï¼Œè¿™ä¸»è¦ç”¨äºç®€åŒ–å†—ä½™çš„æ¥å£ã€‚
    å¦‚æœä½ æœ‰ä¸€ä¸ªå¤æ‚çš„å‡½å­ï¼Œå®ƒç”Ÿæˆäº†å¾ˆå¤šä¸­é—´ç±»å‹ï¼Œä½†ä½ æœ€ç»ˆåªå¸Œæœ›ç”¨æˆ·çœ‹åˆ° int æˆ– stringã€‚ä½¿ç”¨ := å¯ä»¥ï¼š

            1ã€æ¶ˆé™¤å‘½åå¹²æ‰°ï¼šç”¨æˆ·ä¸éœ€è¦å…³å¿ƒä»€ä¹ˆæ˜¯ M.tï¼Œä»€ä¹ˆæ˜¯ M.eltï¼ŒAPI å˜å¾—ç›´è§‚ã€‚
            2ã€é¿å…å†²çªï¼šå¦‚æœå¤šä¸ªæ¥å£ç»„åˆåœ¨ä¸€èµ·ï¼Œå„è‡ªéƒ½æœ‰ type tï¼Œé€šè¿‡ç ´åæ€§æ›¿æ¢å¯ä»¥å°†å®ƒä»¬ç»Ÿä¸€æ›¿æ¢æˆå…·ä½“ç±»å‹ï¼Œæ¶ˆé™¤å‘½åå†²çªã€‚


*)